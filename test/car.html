<html>
<head>
<title>car</title>
</head>

<body>
<script src="https://www.dcodes.org/jshelpers/matrix3.js"></script>
<script>
var canvas = document.createElement("canvas");
canvas.width = 800;
canvas.height = 600;
canvas.style.border = "1px solid black";
document.body.appendChild(canvas);
var context = canvas.getContext("2d");

function line( transform, x1, y1, x2, y2 ) {
	var p1 = transform.mul( Vector3.point(x1, y1) );
	var p2 = transform.mul( Vector3.point(x2, y2) );
	context.moveTo(p1.x, p1.y);
	context.lineTo(p2.x, p2.y);
}

var controls = {
	up: 0,
	down: 0,
	left: 0,
	right: 0
};

var binds = {
	"KeyW": "up",
	"ArrowUp": "up",
	"KeyA": "left",
	"ArrowLeft": "left",
	"KeyS": "down",
	"ArrowDown": "down",
	"KeyD": "right",
	"ArrowRight": "right"
};

document.body.onkeydown = function(evt) {
	var bind = binds[evt.code];
	if( bind ) {
		controls[bind] = 1;
	}
};
document.body.onkeyup = function(evt) {
	var bind = binds[evt.code];
	if( bind ) {
		controls[bind] = 0;
	}
};

var camera = Matrix3.translate( Vector3.vector( canvas.width/2, canvas.height/2 ) );
camera = camera.mul(Matrix3.scale( Vector3.vector(1, -1)) );
camera = camera.mul(Matrix3.scale( Vector3.vector(0.3, 0.3)) );

function clamp( val, min, max ) {
	return Math.max( Math.min( val, max ), min );
}

var decals = {
	next: 0,
	points: [],
	add: function( point ) {
		if( this.points.length < 200 ) {
			this.points.push(point);
		} else {
			this.points[this.next] = point;
			this.next = (this.next + 1) % this.points.length;
		}
	},
	draw: function(camera) {
		for( var i=0; i<this.points.length; i++ ) {
			var point = this.points[i];
			line( camera, point.x, point.y, point.x+1, point.y+1 );
		}
	}
};

var building = {
    draw: function(camera) {
        line( camera, -100,  100,  100,  100 );
        line( camera,  100,  100,  100, -100 );
        line( camera,  100, -100, -100, -100 );
        line( camera, -100, -100, -100,  100 );
    }
};

var block = {
    draw: function(camera) {
        var count = 20;
        line( camera, -150, 150, count * 220 - 150, 150 );
        for( var x=0; x<20; x++ ) {
            var transform = camera;
            transform = transform.mul( Matrix3.translate( Vector3.point( x * 220, 0 ) ) );
            building.draw( transform );
        }
    }
};

var stats = document.createElement( "pre" );
document.body.appendChild( stats );

function wrapAngle( angle ) {
    while( angle < 0 ) {
        angle += Math.PI * 2;
    }
    while( angle > Math.PI * 2 ) {
        angle -= Math.PI * 2;
    }
    return angle;
}
function angleDistance( from, to ) {
    var result = to - from;
    if( result < -Math.PI ) {
        return result + Math.PI * 2;
    }
    if( result > Math.PI ) {
        return result - Math.PI * 2;
    }
    return result;
}

var Tire = function( name, traction ) {
	this.name = name;
	this.traction = traction;
	return this;
};
Tire.prototype.react = function( road, force ) {
	var lateral = clamp(force.x, -this.traction, this.traction);
	if( Math.abs(lateral) === this.traction ) {
		//console.log( `${this.name} ${lateral} ${force.x}` );
		road.add_decal();
	}
	return Vector3.vector( -lateral, 0 );
};

var tire_fl = new Tire("fl",0.50);
var tire_fr = new Tire("fr",0.50);
var tire_bl = new Tire("bl",0.50);
var tire_br = new Tire("br",0.50);

function getRoad( p ) {
	return {
		add_decal: function() {
			decals.add(p);
		}
	};
}

var car = {
	p: Vector3.point(0, 0),
	v: Vector3.vector(0, 0),
	angle: 0,
	steer: 0,
	a: 0,
	w: 0,
	draw: function( camera ) {

		var steer_limit = 0.8;
		var gas_acceleration = 0.1;
		var rear_tire_force = 0.27;
		var front_tire_force = 0.30;
		var steer_amount = 0.4;
		var show_steering = false;

        var car_lateral = Vector3.vector( Math.cos(this.angle), -Math.sin(this.angle) );

		// basic forces
		var steerDirection = controls.right - controls.left;
		var steerStep = steer_amount/ clamp( this.v.getLength(), 4, 10 );
		if( steerDirection ) {
			this.steer = wrapAngle( this.steer + steerDirection * steerStep );
		}
		this.steer = wrapAngle( this.angle + clamp( angleDistance( this.angle, this.steer ), -steer_limit, steer_limit ) );

        this.a = ( controls.up - controls.down ) * gas_acceleration;
		var acceleration = Vector3.vector(
			Math.sin(this.angle) * this.a,
			Math.cos(this.angle) * this.a
		);

        if( acceleration.dot(this.v) >= 0 ) {
            this.v = this.v.add( acceleration );
        } else {
			decals.add(this.p.add(car_lateral.mul(Vector3.vector(5,5))));
			decals.add(this.p.add(car_lateral.mul(Vector3.vector(-5,-5))));
            var brake = -0.2 / this.v.getLength();
            this.v = this.v.add( this.v.mul( Vector3.vector( brake, brake ) ) );
            rear_tire_force = 0;
            front_tire_force = 0.01;
        }

		var wheels = [
			{
				a: this.steer,
				p: Vector3.point(-5,5),
				tire: tire_fl
			},
			{
				a: this.steer,
				p: Vector3.point(5,5),
				tire: tire_fr
			},
			{
				a: this.angle,
				p: Vector3.point(-5,-5),
				tire: tire_bl
			},
			{
				a: this.angle,
				p: Vector3.point(5,-5),
				tire: tire_br
			}
		];
		// wheels
		var carToWorld = Matrix3.identity();
		carToWorld = carToWorld.mul( Matrix3.translate( this.p ) );
		carToWorld = carToWorld.mul( Matrix3.rotate( this.angle ) );
		var reaction_v = Vector3.vector(0, 0);
		var reaction_w = 0;
		for( var i=0; i<wheels.length; i++ ) {
			var wheel = wheels[i];
			
			var wheelPosition = carToWorld.mul(wheel.p);
			var wheelToWorld = Matrix3.identity();
			wheelToWorld = wheelToWorld.mul( Matrix3.translate( wheelPosition ) );
			wheelToWorld = wheelToWorld.mul( Matrix3.rotate( wheel.a ) );
			var worldToWheel = Matrix3.identity();
			worldToWheel = worldToWheel.mul( Matrix3.rotate( -wheel.a ) );
			worldToWheel = worldToWheel.mul( Matrix3.translate( wheelPosition.mul( Vector3.point(-1,-1) ) ) );

			var road = getRoad( wheelPosition );

			var wheelVelocity = worldToWheel.mul( this.v );

			var wheelDistance = wheel.p.mul(Vector3.vector(1,1)).getLength();
			var carAngularDirection = Vector3.vector(wheel.p.y/wheelDistance, -wheel.p.x/wheelDistance);
			var worldAngularDirection = carToWorld.mul( carAngularDirection );
			var wheelAngularDirection = worldToWheel.mul( worldAngularDirection );
			var wheelAngular = wheelAngularDirection.mul( Vector3.vector(wheelDistance*this.w, wheelDistance*this.w) );
			wheelVelocity = wheelVelocity.add( wheelAngular );
			
			var reaction = wheel.tire.react(road, wheelVelocity);
			reaction_v = reaction_v.add(wheelToWorld.mul(reaction));
			var angularAmount = reaction.dot(wheelAngularDirection) / wheelDistance / 4;
			console.log( angularAmount );
			reaction_w = reaction_w + angularAmount;
		}

		console.log( { w: this.w, react: reaction_w } );

		this.v = this.v.add(reaction_v);
		this.w = this.w + reaction_w;

		this.p = this.p.add(this.v);
		this.angle = wrapAngle( this.angle + this.w );

		var transform = camera;
		transform = transform.mul( Matrix3.translate( this.p ) );
		transform = transform.mul( Matrix3.rotate( this.angle ) );
		line( transform, -10,  20,  10,  20 );
		line( transform,  10,  20,  10, -20 );
		line( transform, -10, -20, -10,  20 );
		line( transform,  10, -20, -10, -20 );
		if( show_steering ) {
			line( transform, 0, 10, 0+Math.sin(this.steer-this.angle)*40, 10+Math.cos(this.steer-this.angle)*40);
		}
	}
};

//camera = camera.mul(Matrix3.translate( Vector3.vector( 0, -400 )));

function update() {
	context.clearRect(0, 0, canvas.width, canvas.height);
	context.beginPath();
    var transform = camera;
    //transform = transform.mul( Matrix3.rotate(-car.angle) );
    transform = transform.mul(
        Matrix3.translate(
            car.p.mul(Vector3.vector(-1,-1))
        )
    );
    block.draw( transform );
	car.draw( transform );
	decals.draw( transform );
	context.stroke();
	window.requestAnimationFrame( update );
}
window.requestAnimationFrame( update );
</script>
</body>
</html>
